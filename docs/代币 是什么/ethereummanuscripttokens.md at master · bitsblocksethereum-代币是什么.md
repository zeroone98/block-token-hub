## 什么是代币？



*代币*一词源于古英语“tacen”，意为标记或符号。通常用于表示私人发行的具有微不足道价值的硬币类物品，例如交通代币、洗衣代币、游戏机代币。

如今，基于区块链的代币正在重新定义这个词，表示可以拥有并代表资产、货币或访问权的基于区块链的抽象概念。

“代币”一词与微不足道的价值之间的联系与实物代币的有限使用有很大关系。实物代币通常仅限于特定的企业、组织或地点，不易兑换，也不能用于多种功能。有了区块链代币，这些限制就被消除了。许多代币在全球范围内有多种用途，可以相互交易，也可以在全球流动市场上与其他货币交易。随着这些限制的消失，“微不足道的价值”预期也已成为过去。

在本节中，我们将了解代币的各种用途及其创建方式。我们还将讨论代币的属性，例如可替代性和内在性。最后，我们将研究它们所基于的标准和技术，并通过构建我们自己的代币进行实验。

## 代币如何使用？



代币最明显的用途是作为数字私人货币。然而，这只是一种可能的用途。代币可以被编程为提供许多不同的功能，这些功能通常是重叠的。例如，代币可以同时传达投票权、访问权和资源所有权。货币只是第一个“应用程序”。

货币：代币可以作为一种货币形式，其价值通过私人交易确定。例如以太币或比特币。

资源：代币可以代表在共享经济或资源共享环境中获得或生产的资源。例如，存储或 CPU 代币代表可通过网络共享的资源。

资产：代币可以代表内在或外在、有形或无形资产的所有权。例如黄金、房地产、汽车、石油、能源等。

访问:: 令牌可以代表访问权限，甚至可以传达对数字或物理财产的访问权限，例如讨论论坛、专属网站、酒店房间、租车。

股权：代币可以代表数字组织（例如 DAO）或法律拟制（例如公司）中的股东权益

投票:: 代币可以代表数字或法律系统中的投票权。

收藏品：代币可以代表数字（例如 CryptoPunks）或实物收藏品（例如绘画）

身份：代币可以代表数字（例如头像）或法律身份（例如国民身份证）。

证明：代币可以代表某些权威机构或去中心化声誉系统对事实的认证或证明（例如结婚记录、出生证明、大学学位）。

实用程序:: 代币可用于访问或支付服务。

通常，一个代币就包含多种功能。有时很难区分它们，因为物理等价物总是密不可分。例如，在物理世界中，驾驶执照（证明）也是身份证件（身份），两者无法分离。在数字领域，以前混合的功能可以分离并独立开发（例如匿名证明）。

## 代币和可替代性



来自维基百科：

> 在经济学中，可替代性是指商品或产品中各个单元基本上可以互换的属性。

当我们可以将任何单位的代币替换为另一个单位的代币，而其价值或功能没有任何变化时，代币就是可替代的。例如，以太币是一种可替代代币，因为任何单位的以太币都具有与任何其他单位的以太币相同的价值和用途。

严格来说，如果代币的历史出处可以追踪，那么它就不是完全可替代的。追踪出处的能力可能会导致列入黑名单和白名单，从而降低或消除可替代性。我们将在<>中进一步探讨这一点。

非同质化代币是指代表独特有形或无形物品的代币，因此不可互换。例如，代表*特定*梵高画作所有权的代币并不等同于代表毕加索画作的另一个代币。同样，代表*特定*数字收藏品（例如特定 CryptoKitty（参见 <>））的代币不可与任何其他 CryptoKitty 互换。每个非同质化代币都与唯一标识符（例如序列号）相关联。

在本节后面我们将看到可替代和不可替代代币的示例。

## 交易对手风险



*交易对手风险是指交易中另一方*无法履行义务的风险。某些类型的交易会因为交易中增加了两个以上的交易方而产生额外的交易对手风险。例如，如果您持有贵金属的存款证明并将其出售给某人，则该交易至少涉及三方：卖方、买方和贵金属的保管人。有人持有实物资产，出于必要，他们成为一方，并为涉及该资产的任何交易增加交易对手风险。当资产通过交换所有权代币间接交易时，资产保管人会产生额外的交易对手风险。他们有资产吗？他们会承认（或允许）基于代币（如证书、契约、所有权或数字代币）转让的所有权转移吗？在数字代币的世界中，了解谁持有代币所代表的资产以及哪些规则适用于该基础资产非常重要。

## 代币和内在性



“内在”一词源于拉丁语“intra”，意为“从内部”。

*一些代币代表区块链固有的*数字项目。这些数字资产受共识规则的约束，就像代币本身一样。这有一个重要的含义：代表内在资产的代币不承担额外的交易对手风险。如果您持有 1 个以太币的密钥，则没有其他方为您持有该以太币。区块链共识规则适用，您对私钥的所有权（控制权）等同于对资产的所有权，无需任何中介。

相反，许多代币用于代表*外在*事物，如房地产、公司投票股份、商标、金条。这些不在区块链“内”的物品的所有权受法律、习俗和政策的管辖，这些法律、习俗和政策与管理代币的共识规则无关。换句话说，代币发行者和所有者可能仍然依赖现实世界的非智能合约。因此，这些外在资产承担额外的交易对手风险，因为它们由托管人持有、记录在外部注册机构中或受区块链环境之外的法律和政策控制。

基于区块链的代币最重要的影响之一是能够将外在资产转换为内在资产，从而消除交易对手风险。一个很好的例子是从公司股权（外在）转变为去*中心化自治组织*或类似（内在）组织的股权或投票代币。

## 使用代币：效用还是权益



如今，以太坊上几乎所有项目都以某种代币的形式启动。但所有这些项目真的都需要代币吗？使用代币有什么缺点吗？或者我们会看到“将所有事物代币化”的口号成为现实吗？

首先，让我们先明确代币在新项目中的作用。大多数项目以两种方式之一使用代币：要么作为“实用代币”，要么作为“股权代币”。这两种角色经常被混淆，难以区分。

实用型代币是指需要使用代币来支付服务、应用程序或资源的代币。实用型代币的示例包括代表资源（例如共享存储）、访问社交媒体网络等服务的代币，或作为以太坊平台燃料的以太币本身。相比之下，股权代币则代表初创公司的股份。

股权代币可以像用于分配股息和利润的无投票权股份一样有限，也可以像去中心化自治组织中的投票权股份一样广泛，其中平台的管理是通过代币持有者的多数投票来进行的。

### 这不是鸭子



代币用于为初创公司筹集资金，并不意味着它必须用于支付服务费用，反之亦然。然而，许多初创公司面临着一个难题：代币是一种很好的筹资机制，但在大多数司法管辖区，向公众提供证券（股权）是一项受监管的活动。通过将股权代币伪装成实用代币，许多初创公司希望绕过这些监管限制，通过公开发行筹集资金，同时将其作为实用代币的预售。这些伪装得很隐蔽的股票发行是否能够避开监管机构还有待观察。

正如俗话所说：“如果它走路像鸭子，叫声也像鸭子，那它就是鸭子。”监管者不太可能被这些语义上的扭曲所困扰，恰恰相反，他们更有可能将这种法律诡辩视为欺骗公众的企图。

### 实用代币：谁需要它们？



真正的问题是，实用型代币给初创企业带来了巨大的风险和采用障碍。也许在遥远的未来，“将所有事物代币化”会成为现实。但目前，能够接触、了解并希望使用代币的人数只是本已很小的加密货币市场的一小部分。

对于初创公司来说，每项创新都代表着一种风险和市场过滤器。创新就是走一条人迹罕至的道路，远离传统道路。这已经是一条孤独的道路。如果一家初创公司试图在新的技术领域进行创新，比如通过 P2P 网络共享存储，那么这条路已经够孤独的了。为该创新添加实用代币，并要求用户采用代币才能使用该服务，这加剧了风险，增加了采用的门槛。它正在走出已经很孤独的 P2P 存储创新之路，走向荒野。

将每项创新视为一个过滤器。它将采用限制在可以成为该创新早期采用者的市场子集。添加第二个过滤器会加剧这种影响，进一步限制可寻址市场。你要求早期采用者采用的不仅仅是一项，而是两项全新的技术：你构建的新颖应用程序/平台/服务和代币经济。

对于初创公司来说，每项创新都会带来风险，从而增加初创公司失败的可能性。如果你将已经存在风险的创业想法加上实用代币，那么你就会面临所有风险，包括底层平台（以太坊）、更广泛的经济（交易所、流动性）、监管环境（股票/商品监管机构）和技术（智能合约、代币标准）。这对初创公司来说风险很大。

“将一切代币化”的支持者可能会反驳说，通过采用代币，他们也继承了整个代币经济的市场热情、早期采用者、技术、创新和流动性。这也是事实。问题是好处和热情是否大于风险和不确定性。

尽管如此，一些最具创新性的商业理念确实发生在加密货币领域。如果监管机构不能迅速调整法律并支持新的商业模式，人才和企业家将寻求在其他对加密货币更为友好的司法管辖区开展业务。这实际上正在发生。

最后，在本章开头介绍代币时，我们讨论了代币的口语含义，即“价值微不足道的东西”。大多数代币价值微不足道的根本原因是它们只能在非常狭窄的环境中使用：一家公交公司、一家自助洗衣店、一家商场、一家酒店、一家公司商店。有限的流动性、有限的适用性和高转换成本使代币的价值一路下降，直到它只是一个“代币”价值。因此，当您将实用代币添加到您的平台时，但该代币只能在您自己的一个市场较小的平台上使用，您正在重新创造使物理代币一文不值的条件。如果为了使用您的平台，用户必须将某些东西转换为您的实用代币，使用它，然后将剩余的东西转换回更普遍有用的东西，您就创建了公司代金券。数字代币的转换成本比没有市场的物理代币低几个数量级。但转换成本不为零。适用于整个行业领域的实用型代币将非常有趣，而且可能非常有价值。但是，如果你的初创企业必须引导整个行业标准才能取得成功，那么你可能已经失败了。

在以太坊这样的通用平台上部署服务的好处之一正是能够连接智能合约，增加代币的流动性和实用性的潜力。

做出这个决定要有正确的理由。采用代币是因为您的应用程序*没有代币就无法运行*（例如以太坊）。采用代币是因为代币解决了根本的市场障碍或准入问题。不要引入实用代币，因为这是您快速筹集资金的唯一方式，您需要假装它不是公开发行的证券。

## 代币标准



区块链代币在以太坊之前就已经存在。从某种意义上说，第一个区块链货币比特币本身就是一种代币。在以太坊之前，许多代币平台也是在比特币和其他加密货币上开发的。然而，以太坊上第一个代币标准的引入导致了代币的爆炸式增长。

Vitalik Buterin 认为代币是以太坊等通用可编程区块链最明显、最有用的应用之一。事实上，在以太坊的第一年，经常可以看到 Vitalik 和其他人穿着印有以太坊徽标和背面印有智能合约样本的 T 恤。这种 T 恤有几种变体，但最常见的是代币的实现。

### ERC20 代币标准



第一个标准于 2015 年 11 月由 Fabian Vogelsteller 提出，作为以太坊征求意见 (ERC)。它被自动分配了 GitHub 问题编号 20，从而产生了“ERC20 代币”的名称。目前绝大多数代币都基于 ERC20。ERC20 征求意见最终成为以太坊改进提案 EIP20，但仍然以原始名称 ERC20 来称呼。您可以在此处阅读该标准：

https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md

*ERC20 是可替代代币*的标准，这意味着 ERC20 代币的不同单元可以互换并且没有独特属性。

ERC20 标准为实现代币的合约定义了一个通用接口，这样任何兼容的代币都可以以相同的方式访问和使用。该接口由标准的每个实现中必须存在的许多函数以及开发人员可以添加的一些可选函数和属性组成。

#### ERC20 所需的功能和事件



totalSupply:: 返回此代币当前存在的总单位数。ERC20 代币可以有固定或可变的供应量。

balanceOf:: 给定一个地址，返回该地址的代币余额。

转移:: 给定一个地址和金额，从执行转移的地址的余额将该数量的代币转移到该地址。

transferFrom:: 给定发送者、接收者和金额，将代币从一个账户转移到另一个账户。与下面的 +approve+ 结合使用。

批准:: 给定收件人地址和金额，授权该地址从发出批准的账户执行最多该金额的多次转账。

允许:: 给定一个所有者地址和一个消费者地址，返回消费者被批准从所有者处提取的剩余金额。

转移事件:: 转移成功时触发事件（调用 +transfer+ 或 +transferFrom+）（即使对于零值转移）。

批准事件:: 成功调用 +approve+ 时记录事件。

#### ERC20 可选功能



name:: 返回代币的人类可读名称（例如“美元”）。

符号::返回代币的人类可读符号（例如“USD”）。

decimals:: 返回用于除以代币金额的小数位数。例如，如果 decimals 为 2，则将代币金额除以 100 以获得其用户表示。

#### Solidity中定义的ERC20接口



ERC20 接口规范在 Solidity 中如下所示：

```
contract ERC20 {
   function totalSupply() constant returns (uint theTotalSupply);
   function balanceOf(address _owner) constant returns (uint balance);
   function transfer(address _to, uint _value) returns (bool success);
   function transferFrom(address _from, address _to, uint _value) returns (bool success);
   function approve(address _spender, uint _value) returns (bool success);
   function allowance(address _owner, address _spender) constant returns (uint remaining);
   event Transfer(address indexed _from, address indexed _to, uint _value);
   event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```



#### ERC20 数据结构



如果您检查任何 ERC20 实现，它将包含两个数据结构，一个用于跟踪余额，一个用于跟踪津贴。在 Solidity 中，它们是通过*数据映射*实现的。

第一个数据映射实现了一个按所有者列出的代币余额内部表。这允许代币合约跟踪谁拥有代币。每次转账都是从一个余额中扣除并添加到另一个余额中。

余额：从地址（所有者）到金额（余额）的映射

```
mapping(address => uint256) balances;
```



第二个数据结构是限额的数据映射。正如我们将在 <<transfer_workflows>> 中看到的那样，使用 ERC20 代币，代币所有者可以将权限委托给消费者，允许他们从所有者的余额中支出特定金额（限额）。ERC20 合约使用二维映射来跟踪限额，主键是代币所有者的地址，映射到消费者地址和限额金额：

限额：从地址（所有者）到地址（消费者）到金额（限额）的映射

```
mapping (address => mapping (address => uint256)) public allowed;
```



#### ERC20 工作流程：“转移”和“批准和转移自”



ERC20 代币标准有两种传输功能。您可能想知道为什么？

ERC20 允许两种不同的工作流程。第一种是使用 +transfer+ 函数的单笔交易、简单工作流程。钱包使用此工作流程将代币发送到其他钱包。绝大多数代币交易都通过 +transfer+ 工作流程进行。

执行转账合约非常简单。如果 Alice 想要向 Bob 发送 10 个代币，她的钱包会向代币合约的地址发送一笔交易，以 Bob 的地址和“10”作为参数调用 +transfer+ 函数。代币合约会调整 Alice 的余额（-10）和 Bob 的余额（+10），并发出 +Transfer+ 事件。

第二个工作流程是使用 +approve+ 和 +transferFrom+ 的双交易工作流程。此工作流程允许代币所有者将其控制权委托给另一个地址。它最常用于将控制权委托给代币分发合约，但也可供交易所使用。例如，如果一家公司正在为 ICO 出售代币，他们可以 +approve+ 众筹合约地址来分发一定数量的代币。然后，众筹合约可以将代币合约所有者余额 +transferFrom+ 给代币的每个买家。

ERC20 代币的两步批准和转移工作流程

[![我/批准_transferFrom_workflow.png](https://github.com/bitsblocks/ethereum/raw/master/manuscript/i/approve_transferFrom_workflow.png)](https://github.com/bitsblocks/ethereum/blob/master/manuscript/i/approve_transferFrom_workflow.png)

对于 +approve & transferFrom+ 工作流，需要两个交易。假设 Alice 想要允许 AliceICO 合约将所有 AliceCoin 代币的 50% 出售给 Bob 和 Charlie 等买家。首先，Alice 启动 AliceCoin ERC20 合约，将所有 AliceCoin 发行到她自己的地址。然后，Alice 启动可以出售代币换取以太币的 AliceICO 合约。接下来，Alice 启动 +approve & transferFrom+ 工作流。她向 AliceCoin 发送一个交易，调用 +approve+，其中包含 AliceICO 的地址和 +totalSupply+ 的 50%。这将触发 +Approval+ 事件。现在，AliceICO 合约可以出售 AliceCoin。

当 AliceICO 从 Bob 收到以太币时，它需要向 Bob 发送一些 AliceCoin 作为回报。AliceICO 合约中包含 AliceCoin 和以太币之间的汇率。Alice 在创建 AliceICO 时设置的汇率决定了 Bob 向 AliceICO 发送的以太币数量将获得多少代币。当 AliceICO 调用 AliceCoin +transferFrom+ 函数时，它会将 Alice 的地址设置为发送方，将 Bob 的地址设置为接收方，并使用汇率确定将在“value”字段中向 Bob 转移多少 AliceCoin 代币。AliceCoin 合约将余额从 Alice 的地址转移到 Bob 的地址并触发 +Transfer+ 事件。AliceICO 合约可以无限次调用 +transferFrom+，只要不超过 Alice 设置的批准限制即可。AliceICO 合约可以通过调用 +allowance+ 函数来跟踪它可以出售多少 AliceCoin 代币。

#### ERC20 实现



虽然可以用大约三十行 Solidity 代码实现与 ERC20 兼容的代币，但大多数实现都更为复杂，以解决潜在的安全漏洞。EIP20 标准中提到了两种实现：

Consensys EIP20:: 一种简单易读的 ERC20 兼容令牌的实现。

您可以在此处阅读 Consensys 实现的 Solidity 代码： [https ://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol](https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol)

OpenZeppelin StandardToken:: 此实现与 ERC20 兼容，并具有额外的安全预防措施。它构成了 OpenZeppelin 库的基础，可实现更复杂的 ERC20 兼容代币，包括筹款上限、拍卖、归属时间表和其他功能。

您可以在此处查看 OpenZeppelin StandardToken 的 Solidity 代码： https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol

### 推出我们自己的 ERC20 代币



让我们创建并启动我们自己的代币。对于此示例，我们将使用 +truffle+ 框架（请参阅 <>）。此示例假设您已经安装了 +truffle+、对其进行了配置，并且熟悉其基本操作。

我们的代币名为“Mastering Ethereum Token”，符号为“MET”。

您可以在本书的 GitHub 存储库中找到此示例： [https ://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken](https://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken)

首先，让我们创建并初始化一个 truffle 项目目录，就像我们在 <<truffle_project_directory>> 中所做的一样。运行以下四个命令并接受所有问题的默认答案：

```
$ mkdir METoken
$ cd METoken
METoken $ truffle init
METoken $ npm init
```



您现在应该具有以下目录结构：

```
METoken/
├── contracts
│   └── Migrations.sol
├── migrations
│   └── 1_initial_migration.js
├── package.json
├── test
├── truffle-config.js
└── truffle.js
```



编辑 +truffle.js+ 或 +truffle-config.js+ 配置文件来设置您的 +truffle+ 环境，或者复制我们使用的配置文件：

https://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken/truffle-config.js

如果您使用示例 +truffle-config.js+，请记住在 +METoken+ 文件夹中创建一个文件 +.env+，其中包含您的测试私钥，用于在公共以太坊测试网络（例如 ganache 或 Kovan）上进行测试和部署。您可以从 MetaMask 导出您的测试网络私钥。

之后你的目录如下所示：

```
METoken/
├── contracts
│   └── Migrations.sol
├── migrations
│   └── 1_initial_migration.js
├── package.json
├── test
├── truffle-config.js
├── truffle.js
└── .env *new file*
```



:: [警告] 仅使用未用于在以太坊主网络上保存资金的测试密钥或测试助记符。切勿使用保存真钱的密钥进行测试。::

为了举例，我们将导入 OpenZeppelin StandardContract，它实现了一些重要的安全检查，并且易于扩展。让我们导入该库：

```
$ npm install zeppelin-solidity

+ zeppelin-solidity@1.6.0
added 8 packages in 2.504s
```



+zeppelin-solidity+ 软件包将在 +node_modules+ 目录下添加大约 250 个文件。OpenZeppelin 库包含的内容远不止 ERC20 代币，但我们只会使用其中的一小部分。

接下来，让我们编写代币合约。创建一个新文件 +METoken.sol+ 并从 GitHub 复制示例代码：

https://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken/contracts/METoken.sol

我们的合约非常简单，因为它继承了 OpenZeppelin StandardToken 库的所有功能：

METoken.sol：实现 ERC20 代币的 Solidity 合约

```
include::code/METoken/contracts/METoken.sol[]
```



在这里，我们定义可选变量 +name+、+symbol+ 和 +decimals+。我们还定义了一个*_initial_supply*变量，设置为 2100 万个代币和两位小数（总计 21 亿）。在合约的初始化（构造函数）函数中，我们将 +totalSupply+ 设置为等于*_initial_supply*，并将所有*_initial_supply*分配给创建 +METoken+ 合约的账户（+msg.sender+）的余额。

我们现在使用 +truffle+ 来编译 +METoken+ 代码：

```
$ truffle compile
Compiling ./contracts/METoken.sol...
Compiling ./contracts/Migrations.sol...
Compiling zeppelin-solidity/contracts/math/SafeMath.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/BasicToken.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/ERC20.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/StandardToken.sol...
```



如您所见，+truffle+ 合并了 OpenZeppelin 库中必要的依赖项并编译了这些合约。

让我们设置一个迁移脚本，以部署 +METoken+ 合约。在 +METoken/migrations+ 文件夹中创建一个新文件 +2_deploy_contracts.js+。从 Github 存储库上的示例中复制内容：

https://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken/migrations/2_deploy_contracts.js

它包含以下内容：

2_deploy_contracts.js : 迁移以部署 METoken

```
include::code/METoken/migrations/2_deploy_contracts.js[]
```



在部署到以太坊测试网络之一之前，让我们启动一个本地区块链来测试所有内容。启动 +ganache+ 区块链，可以使用 +ganache-cli+ 从命令行启动，也可以使用图形用户界面启动，就像我们在 <<using_ganache>> 中所做的那样。

一旦 +ganache+ 启动，我们就可以部署我们的 METoken 合约并查看一切是否按预期工作：

```
$ truffle migrate --network ganache
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb2e90a056dc6ad8e654683921fc613c796a03b89df6760ec1db1084ea4a084eb
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying METoken...
  ... 0xbe9290d59678b412e60ed6aefedb17364f4ad2977cfb2076b9b8ad415c5dc9f0
  METoken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...
```



在 +ganache+ 控制台上，我们应该看到我们的部署已经创建了 4 个新交易：

Ganache 上的 METoken 部署

[![我/ganache_metoken.png](https://github.com/bitsblocks/ethereum/raw/master/manuscript/i/ganache_metoken.png)](https://github.com/bitsblocks/ethereum/blob/master/manuscript/i/ganache_metoken.png)

### 使用 truffle 控制台与 METoken 交互



我们可以使用 +truffle console+ 与 +ganache+ 区块链上的合约进行交互。这是一个交互式 JavaScript 环境，可以访问 truffle 环境，并通过 Web3 访问区块链。在本例中，我们将 +truffle console+ 连接到 +ganache+ 区块链：

```
$ truffle console --network ganache
truffle(ganache)>
```



+truffle(ganache)>+ 提示符表明我们已连接到 +ganache+ 区块链并准备好输入命令。+truffle console+ 支持所有 truffle 命令，因此我们可以从控制台 +compile+ 和 +migrate+。我们已经运行了这些命令，因此让我们直接转到合约本身。METoken 合约作为 truffle 环境中的 JavaScript 对象存在。在提示符下输入 +METoken+，它将转储整个合约定义：

```
truffle(ganache)> METoken
{ [Function: TruffleContract]
  _static_methods:

[...]

currentProvider:
 HttpProvider {
   host: 'http://localhost:7545',
   timeout: 0,
   user: undefined,
   password: undefined,
   headers: undefined,
   send: [Function],
   sendAsync: [Function],
   _alreadyWrapped: true },
network_id: '5777' }
```



+METoken+ 对象还公开了几个属性，例如合约的地址（由 +migrate+ 命令部署）：

```
truffle(ganache)> METoken.address
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
```



如果我们想与已部署的合约进行交互，我们必须使用异步调用，以 JavaScript“promise”的形式。我们使用 +deployed+ 函数获取合约实例，然后调用 +totalSupply+ 函数：

```
truffle(ganache)> METoken.deployed().then(instance => instance.totalSupply())
BigNumber { s: 1, e: 9, c: [ 2100000000 ] }
----

Next, let's use the accounts created by +ganache+ to check our METoken balance and send some METoken to another address. First, let's get the account addresses:

[[get_account_addresses]]
----
truffle(ganache)> let accounts
undefined
truffle(ganache)> web3.eth.getAccounts((err,res) => { accounts = res })
undefined
truffle(ganache)> accounts[0]
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
```



+accounts+ 列表现在包含由 +ganache+ 创建的所有帐户，而 +account[0]+ 是部署 METoken 合约的帐户。它应该有 METoken 余额，因为我们的 METoken 构造函数将整个代币供应提供给创建它的地址。让我们检查一下：

```
truffle(ganache)> METoken.deployed().then(instance => { instance.balanceOf(accounts[0]).then(console.log) })
undefined
BigNumber { s: 1, e: 9, c: [ 2100000000 ] }
```



最后，让我们通过调用合约的 +transfer+ 函数将 1000.00 METoken 从 +account[0]+ 转移到 +account[1]+：

```
truffle(ganache)> METoken.deployed().then(instance => { instance.transfer(accounts[1], 100000) })
undefined
truffle(ganache)> METoken.deployed().then(instance => { instance.balanceOf(accounts[0]).then(console.log) })
undefined
truffle(ganache)> BigNumber { s: 1, e: 9, c: [ 2099900000 ] }

undefined
truffle(ganache)> METoken.deployed().then(instance => { instance.balanceOf(accounts[1]).then(console.log) })
undefined
truffle(ganache)> BigNumber { s: 1, e: 5, c: [ 100000 ] }
```



:: [提示] METoken 有 2 个小数点精度，这意味着 1 个 METoken 在合约中代表 100 个单位。当我们转移 1000 个 METoken 时，我们在转移函数中将该值指定为 100,000。::

可以看到，在控制台中，+account[0]+ 现在有 20,999,000 MET，而 +account[1]+ 有 1000 MET。

如果您切换到 +ganache+ 图形用户界面，您将看到调用 +transfer+ 函数的交易：

Ganache 上的 METoken 转账

[![我/ganache_metoken_transfer.png](https://github.com/bitsblocks/ethereum/raw/master/manuscript/i/ganache_metoken_transfer.png)](https://github.com/bitsblocks/ethereum/blob/master/manuscript/i/ganache_metoken_transfer.png)

### 向合约地址发送 ERC20 代币



到目前为止，我们已经设置了一个 ERC20 代币并从一个账户转移到另一个账户。我们用于这些演示的所有账户都是外部拥有账户 (EOA)，这意味着它们由私钥而不是合约控制。如果我们将 MET 发送到合约地址会发生什么？让我们来看看！

首先，让我们将另一份合约部署到我们的测试环境中。在此示例中，我们将使用我们的第一个合约 +Faucet.sol+。让我们将其复制到 +contracts+ 目录，将其添加到 METoken 项目中。我们的目录应如下所示：

```
METoken/
├── contracts
│   ├── Faucet.sol
│   ├── METoken.sol
│   └── Migrations.sol
```



我们还将添加迁移，以便分别部署 +Faucet+ 和 +METoken+：

```
var Faucet = artifacts.require("Faucet");

module.exports = function(deployer) {
  // Deploy the Faucet contract as our only task
  deployer.deploy(Faucet);
};
```



让我们从 truffle 控制台编译并迁移合约：

```
$ truffle console --network ganache
truffle(ganache)> compile
Compiling ./contracts/Faucet.sol...
Writing artifacts to ./build/contracts

truffle(ganache)> migrate
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x89f6a7bd2a596829c60a483ec99665c7af71e68c77a417fab503c394fcd7a0c9
  Migrations: 0xa1ccce36fb823810e729dce293b75f40fb6ea9c9
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0x28d0da26f48765f67e133e99dd275fac6a25fdfec6594060fd1a0e09a99b44ba
  METoken: 0x7d6bf9d5914d37bcba9d46df7107e71c59f3791f
Saving artifacts...
Running migration: 3_deploy_faucet.js
  Deploying Faucet...
  ... 0x6fbf283bcc97d7c52d92fd91f6ac02d565f5fded483a6a0f824f66edc6fa90c3
  Faucet: 0xb18a42e9468f7f1342fa3c329ec339f254bc7524
Saving artifacts...
```



太好了。现在让我们向 +Faucet+ 合约发送一些 MET：

```
truffle(ganache)> METoken.deployed().then(instance => { instance.transfer(Faucet.address, 100000) })
truffle(ganache)> METoken.deployed().then(instance => { instance.balanceOf(Faucet.address).then(console.log)})
truffle(ganache)> BigNumber { s: 1, e: 5, c: [ 100000 ] }
```



好的，我们已经将 1000 MET 转入 +Faucet+ 合约。现在，我们如何从 +Faucet+ 提现？

请记住，+Faucet.sol+ 是一个非常简单的合约。它只有一个函数 +withdraw+，用于提取*以太币*。它没有提取 MET 或任何其他 ERC20 代币的函数。如果我们使用 +withdraw+，它将尝试发送以太币，但由于水龙头还没有以太币余额，它将失败。+METoken+ 合约知道 +Faucet+ 有余额，但它转移该余额的唯一方法是从合约地址收到 +transfer+ 调用。我们需要以某种方式让 +Faucet+ 合约调用 +METoken+ 中的 +transfer+ 函数。

如果你不知道下一步该做什么，那就别想了。这个问题没有解决办法。发送给 +Faucet+ 的 MET 被永远卡住了。只有 +Faucet+ 合约可以转移它，而 +Faucet+ 合约没有代码来调用 ERC20 代币合约的 +transfer+ 函数。

也许您预料到了这个问题。但很可能您没有预料到。事实上，数百名以太坊用户也没有预料到，他们不小心将各种代币转移到了没有任何 ERC20 功能的合约中。据估计，价值超过 250 万美元的代币就这样“卡住了”，永远消失了。

ERC20 代币用户在转账过程中无意中丢失代币的方式之一是当他们试图将代币转移到交易所或其他服务时。他们从交易所的网站上复制一个以太坊地址，以为他们可以直接向其发送代币。然而，许多交易所发布的接收地址实际上是合约！这些合约具有多种不同的功能，最常见的是将发送给它们的所有资金转移到“冷存储”或其他中心化钱包。尽管有许多警告说“不要将代币发送到此地址”，但许多代币还是以这种方式丢失。

### 演示批准和转移工作流程



我们的 +Faucet+ 合约无法处理 ERC20 代币。使用 +transfer+ 函数向其发送代币会导致这些代币丢失。让我们重写合约并使其处理 ERC20 代币。具体来说，我们将把它变成一个水龙头，向任何询问的人提供 MET。

对于此示例，我们复制 truffle 项目目录，将其命名为 +METoken_METFaucet+，初始化 truffle、npm，安装 OpenZeppelin 依赖项并复制 +METoken.sol+ 合约。请参阅我们的第一个示例 <<METoken_example>> 了解详细说明。

现在，让我们创建一个新的水龙头合约，将其命名为 +METFaucet.sol+。它看起来像这样：

METFaucet.sol：METoken 的水龙头

```
include::code/METoken_METFaucet/contracts/METFaucet.sol
```



我们对基本水龙头示例进行了大量更改。由于 METFaucet 将使用 +METoken+ 中的 +transferFrom+ 函数，因此它需要两个额外的变量。一个变量将保存已部署的 +METoken+ 合约的地址。另一个变量将保存 MET 所有者的地址，MET 所有者将批准水龙头提款。+METFaucet+ 将调用 +METoken.transferFrom+ 并指示它将 MET 从所有者转移到水龙头提款请求来自的地址。

我们在这里声明这两个变量：

```
StandardToken public METoken;
address public METOwner;
```



由于我们的水龙头需要使用 +METoken+ 和 +METOwner+ 的正确地址进行初始化，因此我们需要声明一个自定义构造函数：

```
// METFaucet constructor, provide the address of METoken contract and
// the owner address we will be approved to transferFrom
function METFaucet(address _METoken, address _METOwner) public {

	// Initialize the METoken from the address provided
	METoken = StandardToken(_METoken);
	METOwner = _METOwner;
}
```



下一个变化是 +withdraw+ 函数。+METFaucet+ 不再调用 +transfer+，而是使用 +METoken+ 中的 +transferFrom+ 函数，并要求 +METoken+ 将 MET 转移给水龙头接收者：

```
// Use the transferFrom function of METoken
METoken.transferFrom(METOwner, msg.sender, withdraw_amount);
```



最后，由于我们的水龙头不再发送以太币，我们可能应该阻止任何人向 +METFaucet+ 发送以太币，因为我们不希望它卡住。我们更改了 fallback payable 函数以拒绝传入的以太币，并使用 +revert+ 函数来恢复任何传入的付款：

```
// REJECT any incoming ether
function () public payable { revert(); }
```



现在我们的 +METFaucet.sol+ 代码已准备就绪，我们需要修改迁移脚本来部署它。此迁移脚本将稍微复杂一些，因为 +METFaucet+ 依赖于 +METoken+ 的地址。我们将使用 JavaScript 承诺按顺序部署这两个合约。创建 +2_deply_contracts.js+，如下所示：

```
var METoken = artifacts.require("METoken");
var METFaucet = artifacts.require("METFaucet");
var owner = web3.eth.accounts[0];

module.exports = function(deployer) {

	// Deploy the METoken contract first
	deployer.deploy(METoken, {from: owner}).then(function() {
		// then deploy METFaucet and pass the address of METoken
		// and the address of the owner of all the MET who will approve METFaucet
		return deployer.deploy(METFaucet, METoken.address, owner);
  	});
}
```



现在，我们可以在 truffle 控制台中测试所有内容。首先，我们使用 +migrate+ 部署合约。部署 +METoken+ 后，它会将所有 MET 分配给创建它的帐户 +web3.eth.accounts[0]+。然后，我们调用 METoken 中的 +approve+ 函数来批准 +METFaucet+ 代表 +web3.eth.accounts[0]+ 发送最多 1000 MET。最后，为了测试我们的水龙头，我们从 +web3.eth.accounts[1]+ 调用 +METFaucet.withdraw+ 并尝试提取 10 MET。以下是控制台命令：

```
$ truffle console --network ganache
truffle(ganache)> migrate
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x79352b43e18cc46b023a779e9a0d16b30f127bfa40266c02f9871d63c26542c7
  Migrations: 0xaa588d3737b611bafd7bd713445b314bd453a5c8
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0xc42a57f22cddf95f6f8c19d794c8af3b2491f568b38b96fef15b13b6e8bfff21
  METoken: 0xf204a4ef082f5c04bb89f7d5e6568b796096735a
  Replacing METFaucet...
  ... 0xd9615cae2fa4f1e8a377de87f86162832cf4d31098779e6e00df1ae7f1b7f864
  METFaucet: 0x75c35c980c0d37ef46df04d31a140b65503c0eed
Saving artifacts...
truffle(ganache)> METoken.deployed().then(instance => { instance.approve(METFaucet.address, 100000) })
truffle(ganache)> METoken.deployed().then(instance => { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })
truffle(ganache)> BigNumber { s: 1, e: 0, c: [ 0 ] }
truffle(ganache)> METFaucet.deployed().then(instance => { instance.withdraw(1000, {from:web3.eth.accounts[1]}) } )
truffle(ganache)> METoken.deployed().then(instance => { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })
truffle(ganache)> BigNumber { s: 1, e: 3, c: [ 1000 ] }
```



从结果中可以看出，我们可以使用 +approve+ 和 +transferFrom+ 工作流来授权一个合约转移另一个代币中定义的代币。如果使用得当，ERC20 代币可以被外部拥有的地址和其他合约使用。

然而，正确管理 ERC20 代币的负担被推到了用户界面上。如果用户错误地尝试将 ERC20 代币转移到合约地址，而该合约不具备接收 ERC20 代币的功能，则代币将丢失。

### ERC20 代币的问题



ERC20 代币标准的采用确实具有爆炸性。已经发行了数千种代币，既是为了试验新功能，也是为了在各种“众筹”拍卖和首次代币发行 (ICO) 中筹集资金。然而，也存在一些潜在的陷阱，正如我们在将代币转移到合约地址的问题上所看到的那样。

ERC20 代币的一个不太明显的问题是，它们暴露了代币和以太币本身之间的细微差别。当以太币通过以收件人地址为目的地的交易进行转移时，代币转移发生在*特定的代币合约状态*中，并以代币合约为目的地，而不是收件人的地址。代币合约跟踪余额并发出事件。在代币转移中，实际上没有交易发送给代币的收件人。相反，收件人的地址被添加到代币合约本身内的映射中。将以太币发送到地址的交易会改变地址的状态。将代币转移到地址的交易只会改变代币合约的状态，而不会改变收件人地址的状态。即使是支持 ERC20 代币的钱包也不会知道代币余额，除非用户明确添加要“监视”的特定代币合约。一些钱包会监视最流行的代币合约，以检测他们控制的地址持有的余额，但这仅限于可用的 ERC20 合约的一小部分。

事实上，用户不太可能*想要*跟踪所有可能的 ERC20 代币合约中的所有余额。许多 ERC20 代币更像是垃圾邮件，而不是可用的代币。它们会自动为有以太币活动的账户创建余额，以吸引用户。如果你有一个具有长期活动历史的以太坊地址，特别是如果它是在预售中创建的，你会发现它充满了不知从何而来的“垃圾”代币。当然，该地址实际上并不是充满了代币，而是包含你地址的代币合约。只有当你用来查看地址的区块浏览器或钱包正在监视这些代币合约时，你才能看到这些余额。

代币的行为方式与以太币不同。以太币通过 +send+ 函数发送，并由合约中的任何可支付函数或任何外部拥有的地址接受。代币使用仅存在于 ERC20 合约中的 +transfer+ 或 +approve & transferFrom+ 函数发送，并且不会（至少在 ERC20 中）触发接收方合约中的任何可支付函数。代币的功能与以太币等加密货币一样，但它们具有某些微妙的区别，打破了这种幻想。

考虑另一个问题。要发送以太币或使用任何以太坊合约，您需要以太币来支付 gas。要发送代币，您*还需要以太币*。您无法使用代币支付交易的 gas，代币合约也无法为您支付 gas。这可能会导致一些相当奇怪的用户体验。例如，假设您使用交易所或 Shapeshift 将一些比特币转换为代币。您在跟踪该代币合约并显示您的余额的钱包中“收到”代币。它看起来与您钱包中的任何其他加密货币相同。现在尝试发送代币，您的钱包会通知您需要以太币才能执行此操作。您可能会感到困惑 - 毕竟您不需要以太币来接收代币。也许你没有以太币。也许你甚至不知道该代币是以太坊上的 ERC20 代币，也许你认为它是一种拥有自己的区块链的加密货币。幻想破灭了。

其中一些问题特定于 ERC20 代币。其他一些则是与以太坊内的抽象和接口边界有关的更普遍的问题。有些可以通过更改代币接口来解决，其他一些可能需要更改以太坊内的基本结构（例如 EOA 和合约之间的区别，以及交易和消息之间的区别）。有些问题可能无法完全“解决”，可能需要用户界面设计来隐藏细微差别，并使用户体验保持一致，而不管底层区别如何。

在接下来的部分中，我们将研究试图解决其中一些问题的各种提案。

### ERC223——拟议的代币合约接口标准



ERC223 提案试图通过检测目标地址是否为合约来解决无意中将代币转移到合约（可能支持也可能不支持代币）的问题。ERC223 要求设计用于接受代币的合约实现名为 +tokenFallback+ 的函数。如果转账的目的地是合约，而合约不支持代币（即未实现 +tokenFallback+），则转账失败。

为了检测目标地址是否是合约，ERC223 参考实现使用了一小段内联字节码，这种方式颇具创意：

```
function isContract(address _addr) private view returns (bool is_contract) {
	uint length;
	assembly {
		  //retrieve the size of the code on target address, this needs assembly
		  length := extcodesize(_addr)
	}
	return (length>0);
}
```



您可以在此处看到有关 ERC223 提案的讨论：

[以太坊/EIP#223](https://github.com/ethereum/EIPs/issues/223)

ERC223合约接口规范为：

```
interface ERC223Token {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);

  function name() public view returns (string _name);
  function symbol() public view returns (string _symbol);
  function decimals() public view returns (uint8 _decimals);
  function totalSupply() public view returns (uint256 _supply);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}
```



ERC223 尚未得到广泛实施，ERC 讨论线程中存在一些关于向后兼容性以及在合约接口级别和用户界面级别实施更改之间的权衡的争论。争论仍在继续。

### ERC777——拟议的代币合约接口标准



另一个改进代币合约标准的提案是 ERC777。该提案有几个目标，包括：

- 提供 ERC20 兼容接口
- 使用 +send+ 函数传输代币，类似于以太币传输
- 兼容ERC820代币合约注册
- 合约和地址可以通过在发送之前调用的 +tokensToSend+ 函数来控制发送哪些代币
- 通过调用接收方的 +tokensReceived+ 函数来通知合约和地址
- 代币转移交易包含 +userData+ 和 +operatorData+ 字段中的元数据
- 以相同的方式操作，无论是发送到合同还是 EOA

有关 ERC777 的详细信息和正在进行的讨论可以在这里找到： [ethereum/EIPs#777](https://github.com/ethereum/EIPs/issues/777)

ERC777合约接口规范为：

```
interface ERC777Token {
    function name() public constant returns (string);
    function symbol() public constant returns (string);
    function totalSupply() public constant returns (uint256);
    function granularity() public constant returns (uint256);
    function balanceOf(address owner) public constant returns (uint256);

    function send(address to, uint256 amount) public;
    function send(address to, uint256 amount, bytes userData) public;

    function authorizeOperator(address operator) public;
    function revokeOperator(address operator) public;
    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);
    function operatorSend(address from, address to, uint256 amount, bytes userData, bytes operatorData) public;

    event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes userData, bytes operatorData);
    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);
    event Burned(address indexed operator, address indexed from, uint256 amount, bytes userData, bytes operatorData);
    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
    event RevokedOperator(address indexed operator, address indexed tokenHolder);
}
```



提案中链接了 ERC777 的参考实现。ERC777 依赖于 ERC820 中指定的注册合约的并行提案。关于 ERC777 的一些争论是关于同时采用两项重大变化的复杂性：新的代币标准和注册标准。讨论仍在继续。

### ERC721 - 非同质化代币（契约）标准



到目前为止，我们研究的所有代币标准都是*可替代*代币，这意味着每个代币单位都是完全可互换的。 ERC20 代币标准仅跟踪每个账户的最终余额，而不（明确）跟踪任何代币的来源。

*ERC721 提案是针对非同质化*代币（也称为*契约）*的标准。

摘自牛津词典：

> 契约：签署并交付的法律文件，尤其是有关财产所有权或合法权利的文件。

契约一词的使用旨在反映“财产所有权”部分，尽管契约在任何司法管辖区都不被承认为“法律文件”，至少目前如此。

非同质化代币追踪独特物品的所有权。所拥有的物品可以是数字物品，例如游戏物品或数字收藏品。或者，该物品可以是所有权通过代币追踪的实物，例如房屋、汽车、艺术品。契约也可以代表具有负值的物品，例如贷款（债务）、留置权、地役权等。ERC721 标准对所有权通过契约追踪的物品的性质没有任何限制或期望，只是要求它可以被唯一识别，在本标准中，这通过 256 位标识符实现。

标准和讨论的详细信息在两个不同的 GitHub 位置中跟踪：

初步提案： [ethereum/EIPs#721](https://github.com/ethereum/EIPs/issues/721)

继续讨论： [ethereum/EIPs#841](https://github.com/ethereum/EIPs/pull/841)

要了解 ERC20 和 ERC721 之间的基本区别，只需看看 ERC721 中使用的内部数据结构：

```
// Mapping from deed ID to owner
mapping (uint256 => address) private deedOwner;
```



ERC20 跟踪属于每个所有者的余额，所有者是映射的主键，而 ERC721 跟踪每个契约 ID 及其所有者，契约 ID 是映射的主键。从这一基本差异中流露出非同质化代币的所有属性。

ERC721合约接口规范为：

```
interface ERC721 /* is ERC165 */ {
    event Transfer(address indexed _from, address indexed _to, uint256 _deedId);
    event Approval(address indexed _owner, address indexed _approved, uint256 _deedId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    function balanceOf(address _owner) external view returns (uint256 _balance);
    function ownerOf(uint256 _deedId) external view returns (address _owner);
    function transfer(address _to, uint256 _deedId) external payable;
    function transferFrom(address _from, address _to, uint256 _deedId) external payable;
    function approve(address _approved, uint256 _deedId) external payable;
    function setApprovalForAll(address _operateor, boolean _approved) payable;
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
```



ERC721 还支持两个**可选**接口，一个用于元数据，一个用于契约和所有者的枚举。

ERC721 元数据可选接口是：

```
interface ERC721Metadata /* is ERC721 */ {
    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function deedUri(uint256 _deedId) external view returns (string _deedUri);
}
```



ERC721 枚举可选接口为：

```
interface ERC721Enumerable /* is ERC721 */ {
    function totalSupply() external view returns (uint256 _count);
    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);
    function countOfOwners() external view returns (uint256 _count);
    function ownerByIndex(uint256 _index) external view returns (address _owner);
    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId);
}
```



## 代币标准



在本节中，我们回顾了几个提议的标准，以及几个广泛部署的代币合约标准。这些标准到底有什么用？你应该使用这些标准吗？你应该如何使用它们？你应该在这些标准之外添加功能吗？你应该使用哪些标准？接下来我们将研究所有这些问题。

### 什么是代币标准？其用途是什么？



代币标准是实现的*最低*规范。这意味着，为了符合 ERC20 标准，您至少需要实现 ERC20 指定的功能和行为。您还可以通过实现不属于标准的功能来自由*添加功能。*

这些标准的主要目的是促进合约之间的*互操作性*。因此，所有钱包、交易所、用户界面和其他基础设施组件都可以以可预测的方式与任何遵循该规范的合约*进行交互。*

标准旨在*描述性*，而非*规定性*。如何选择实现这些功能取决于您——合约的内部功能与标准无关。它们有一些功能要求，这些要求控制特定情况下的行为，但它们并未规定实现方式。如果将值设置为零，则传递函数的行为就是一个例子。

### 您应该使用这些标准吗？



面对所有这些标准，每个开发人员都面临着一个困境：使用现有标准还是超越其所施加的限制进行创新？

这个困境并不容易解决。标准必然会限制你的创新能力，因为它会形成一个你必须遵循的狭窄“框架”。另一方面，基本标准是从数百个应用程序的经验中产生的，通常可以很好地适应 99% 的用例。

作为这一考虑的一部分，还有一个更大的问题：互操作性和广泛采用的价值。如果您选择使用现有标准，您将获得所有设计为与该标准兼容的系统的价值。如果您选择背离标准，您必须考虑自己构建所有支持基础设施的成本，或说服其他人支持您的实施作为新标准的成本。开辟自己的道路并忽视现有标准的倾向被称为“非我发明”，这与开源文化背道而驰。另一方面，进步和创新有时取决于背离传统。这是一个棘手的选择，所以请仔细考虑！

维基百科“非我发明”（https://en.wikipedia.org/wiki/Not_invented_here）

> 这里并非发明了一种社会、企业或机构文化所采取的立场，即由于外部来源和成本（例如特许权使用费）而避免使用或购买已经存在的产品、研究、标准或知识。

## 到期担保



除了标准的选择，还有并行的*实现*选择。当您决定使用标准（例如 ERC20）时，您必须决定如何实现兼容的代币。以太坊生态系统中广泛使用了许多现有的“参考”实现。或者您可以从头开始编写自己的实现。同样，这种选择代表着一个可能产生严重安全隐患的困境。

现有的实现都是“经过实战检验的”。虽然无法证明它们是安全的，但其中许多都支撑着数百万美元的代币。它们受到了反复而猛烈的攻击。到目前为止，还没有发现任何重大漏洞。编写自己的实现并不容易——有很多微妙的方式可以破坏合约。使用经过充分测试的广泛使用的实现要安全得多。在上面的例子中，我们使用了 ERC20 标准的 OpenZeppelin 实现，因为这个实现从一开始就注重安全性。

如果您使用现有的实现，也可以对其进行扩展。同样，要小心这种冲动。复杂性是安全性的敌人。您添加的每一行代码都会扩大合约的*攻击面*，并可能代表潜在的漏洞。您可能不会注意到问题，直到您在合约上投入大量价值并有人破坏它。

## 代币接口标准的扩展



本节讨论的代币标准以非常小的接口开始，功能有限。许多项目已经创建了扩展实现，以支持其应用程序所需的功能。其中包括：

所有者控制:: 特定地址或地址集（多重签名）被赋予特殊功能，例如黑名单、白名单、铸造、恢复等。

焚烧：代币焚烧是指通过将代币转移到无法使用的地址或抹去余额并减少供应量来故意销毁代币。

铸造:: 以可预测的速度或通过代币创建者的“法令”增加代币总供应量的能力。

众筹:: 提供代币出售的能力，例如通过拍卖、市场销售、反向拍卖等。

上限:: 对总供应量的预定义和不可变的限制，与“铸造”功能相反。

恢复“后门”：：可以通过指定地址或一组地址（多重签名）激活的恢复资金、逆转转移或拆除代币的功能。

白名单：限制代币仅向列出的地址转移的能力。最常用于在经过不同司法管辖区的规则审查后向“合格投资者”提供代币。通常有一个更新白名单的机制。

黑名单：通过禁止特定地址来限制代币转移的能力。通常有一个更新黑名单的功能。

许多这些函数都有一些参考实现，例如在 OpenZeppelin 库中。其中一些是特定于用例的，并且仅在少数令牌中实现。到目前为止，这些函数的接口还没有被广泛接受的标准。

如前所述，决定通过附加功能扩展令牌标准代表了创新/风险和互操作性/安全性之间的权衡。

## 代币和 ICO



代币已成为以太坊生态系统的爆炸性发展。代币很可能成为以太坊等所有智能合约平台非常重要的基础组成部分。

然而，这些标准的重要性和未来影响不应与对当前代币发行的认可相混淆。与任何早期技术一样，第一波产品和公司几乎都会失败，有些会失败得非常惨烈。如今以太坊上提供的许多代币几乎都是不加掩饰的骗局、传销和敛财手段。

关键在于将这项技术的长期愿景和影响（可能非常巨大）与充斥着欺诈行为的代币 ICO 的短期泡沫区分开来。两者可能同时存在。代币标准和平台将在当前的代币狂热中生存下来，然后它们可能会改变世界。